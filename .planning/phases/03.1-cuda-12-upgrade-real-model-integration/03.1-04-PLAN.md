---
phase: 03.1-cuda-12-upgrade
plan: 04
type: execute
wave: 3
depends_on: ["03.1-02"]
files_modified:
  - app/models/reconviagen.py
autonomous: true

must_haves:
  truths:
    - "ReconViaGen model loads TRELLIS weights successfully"
    - "Inference produces real 3D mesh geometry (not placeholder cube)"
    - "Output mesh has >1000 vertices (real geometry, not placeholder)"
    - "Texture/GLB file exists and is >1KB"
    - "postprocessing_utils.to_glb() handles mesh extraction internally"
  artifacts:
    - path: "app/models/reconviagen.py"
      provides: "Real ReconViaGen implementation using TRELLIS"
      contains: "TrellisPipelineWrapper"
      min_lines: 150
  key_links:
    - from: "app/models/reconviagen.py"
      to: "app/models/trellis/pipeline.py"
      via: "TrellisPipelineWrapper import"
      pattern: "from app.models.trellis import TrellisPipelineWrapper"
    - from: "app/models/reconviagen.py"
      to: "trellis.utils.postprocessing_utils"
      via: "to_glb export"
      pattern: "postprocessing_utils.to_glb"
---

<objective>
Replace ReconViaGen STUB with real TRELLIS-based implementation

Purpose: Enable actual 3D reconstruction from multi-view images using TRELLIS-VGGT model
Output: Working ReconViaGen model that produces real textured meshes via GLB export
</objective>

<execution_context>
@/home/devuser/.claude/get-shit-done/workflows/execute-plan.md
@/home/devuser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03.1-cuda-12-upgrade-real-model-integration/03.1-RESEARCH.md
@.planning/phases/03.1-cuda-12-upgrade-real-model-integration/03.1-02-SUMMARY.md
@app/models/reconviagen.py
@app/models/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace ReconViaGen STUB with TRELLIS implementation using to_glb pattern</name>
  <files>app/models/reconviagen.py</files>
  <action>
Rewrite app/models/reconviagen.py to use real TRELLIS pipeline with the CORRECT mesh export pattern.

IMPORTANT: Use `postprocessing_utils.to_glb(gs, mesh)` for mesh export - this is the official Stable-X pattern
that handles mesh extraction internally. Do NOT manually extract mesh attributes (vertices, faces, etc.) as
the internal TRELLIS mesh format is not stable.

NOTE: This implementation is based on estheryang11/ReconViaGen (app_refine.py) which wraps TRELLIS-VGGT
with optimized camera registration via VGGT.

```python
"""
ReconViaGen model wrapper for 3D reconstruction.

Uses TRELLIS-VGGT pipeline for sparse-view 3D reconstruction.
Based on: https://github.com/estheryang11/ReconViaGen (app_refine.py)
Reference: https://huggingface.co/spaces/Stable-X/ReconViaGen

Note: VGGT camera estimation is bundled within TRELLIS-VGGT pipeline.
No separate camera estimation step needed.

STATUS: REAL IMPLEMENTATION (Phase 3.1)
- Uses TRELLIS-VGGT model from Stable-X (via estheryang11/ReconViaGen)
- Produces actual textured 3D meshes via GLB export
"""
import os
# CRITICAL: Set SPCONV_ALGO before any trellis imports
os.environ['SPCONV_ALGO'] = 'native'

import logging
import tempfile
from pathlib import Path
from typing import Optional, List

import torch
from PIL import Image

from app.models.base import BaseReconstructionModel
from app.models.trellis import TrellisPipelineWrapper
from app.services.mesh_export import validate_mesh_output
from app.services.vram_manager import cleanup_gpu_memory, check_vram_available

logger = logging.getLogger(__name__)

# Model configuration
WEIGHTS_PATH = Path("/app/weights/reconviagen")
REQUIRED_VRAM_GB = 16.0  # TRELLIS needs ~14-16GB for inference
INFERENCE_TIMEOUT_SEC = 1800  # 30 minutes


class ReconViaGenModel(BaseReconstructionModel):
    """
    ReconViaGen reconstruction model using TRELLIS-VGGT.

    Converts multi-view RGB + depth images to textured 3D mesh
    using diffusion-based 3D generation.

    Based on estheryang11/ReconViaGen which uses:
    - TRELLIS-VGGT pipeline for 3D reconstruction
    - VGGT (bundled) for camera pose estimation
    - app_refine.py optimizations for camera registration
    """

    model_name = "reconviagen"

    def __init__(self, celery_task=None):
        super().__init__(celery_task)
        self._device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self._pipeline: Optional[TrellisPipelineWrapper] = None

    def load_weights(self) -> None:
        """
        Load TRELLIS-VGGT model weights.

        Raises:
            FileNotFoundError: If weights not found
            RuntimeError: If insufficient VRAM
        """
        self.report_progress(5, "Checking VRAM availability")

        # Check VRAM before loading
        vram_status = check_vram_available(REQUIRED_VRAM_GB)
        if not vram_status['available']:
            raise RuntimeError(
                f"Insufficient VRAM: {vram_status['free_gb']:.1f}GB available, "
                f"{REQUIRED_VRAM_GB}GB required"
            )

        self.report_progress(10, "Loading TRELLIS-VGGT model")
        logger.info(f"Loading ReconViaGen (TRELLIS) weights")

        # Check if weights need to be downloaded
        weights_dir = WEIGHTS_PATH / "trellis-vggt"
        if not weights_dir.exists():
            self.report_progress(12, "Downloading model weights (first run)")
            download_result = self.download_weights()
            if download_result['status'] == 'failed':
                raise RuntimeError(f"Failed to download weights: {download_result.get('error')}")

        try:
            self._pipeline = TrellisPipelineWrapper(
                model_id="Stable-X/trellis-vggt-v0-2",
                device="cuda"
            )
            self._pipeline.load()
            logger.info("ReconViaGen model loaded successfully")
            self.report_progress(20, "Model loaded")

        except Exception as e:
            logger.error(f"Failed to load TRELLIS model: {e}")
            raise RuntimeError(f"Failed to load model: {e}")

    def inference(self, input_dir: Path, output_dir: Path) -> dict:
        """
        Run ReconViaGen inference on input images.

        Args:
            input_dir: Directory with views/ and depth/ subdirectories
            output_dir: Directory for mesh.glb, mesh.obj, mesh.ply

        Returns:
            dict with status, mesh_path, texture_path, or error
        """
        input_dir = Path(input_dir)
        output_dir = Path(output_dir)

        try:
            # Step 1: Load input images
            self.report_progress(25, "Loading input images")

            views_dir = input_dir / "views"
            depth_dir = input_dir / "depth"

            if not views_dir.exists() or not depth_dir.exists():
                return {
                    'status': 'failed',
                    'error': "Input directory missing views/ or depth/ subdirectory"
                }

            # Load images
            images = self._load_images(views_dir)
            if not images:
                return {
                    'status': 'failed',
                    'error': "No valid images found in views directory"
                }

            logger.info(f"Loaded {len(images)} input images")

            # Step 2: Run TRELLIS inference
            self.report_progress(35, "Running TRELLIS reconstruction")
            logger.info("Starting TRELLIS inference")

            if self._pipeline is None:
                return {
                    'status': 'failed',
                    'error': "Model not loaded. Call load_weights() first."
                }

            # Run the pipeline
            self.report_progress(40, "Generating 3D structure")
            outputs, _, _ = self._pipeline.run(
                images=images,
                seed=42,
                sparse_steps=30,
                sparse_cfg=7.5,
                slat_steps=12,
                slat_cfg=3.0,
            )

            self.report_progress(70, "Extracting mesh")

            # Get gaussian and mesh from outputs
            if 'gaussian' not in outputs or 'mesh' not in outputs:
                return {
                    'status': 'failed',
                    'error': "TRELLIS did not produce gaussian/mesh output"
                }

            if len(outputs['gaussian']) == 0 or len(outputs['mesh']) == 0:
                return {
                    'status': 'failed',
                    'error': "TRELLIS produced empty gaussian/mesh output"
                }

            gs = outputs['gaussian'][0]
            mesh = outputs['mesh'][0]

            # Step 3: Export mesh using official to_glb pattern
            # This is the CORRECT way to export - handles internal mesh format automatically
            self.report_progress(80, "Exporting mesh files")
            output_dir.mkdir(parents=True, exist_ok=True)

            glb_path = output_dir / "mesh.glb"

            try:
                # Import postprocessing_utils from trellis
                from trellis.utils import postprocessing_utils

                # Use the official Stable-X pattern for GLB export
                # This handles mesh extraction internally - no manual attribute access needed
                glb = postprocessing_utils.to_glb(
                    gs,          # Gaussian representation
                    mesh,        # Mesh object (MeshExtractResult)
                    simplify=0.95,        # Mesh simplification factor
                    texture_size=1024,    # Texture resolution
                    verbose=False
                )

                # Export the GLB file
                glb.export(str(glb_path))
                logger.info(f"Exported GLB mesh to {glb_path}")

            except Exception as e:
                logger.error(f"Failed to export mesh via to_glb: {e}")
                return {
                    'status': 'failed',
                    'error': f"Mesh export failed: {str(e)}"
                }

            # Step 4: Convert GLB to OBJ/PLY for compatibility (optional)
            self.report_progress(85, "Converting to OBJ/PLY formats")
            obj_path, ply_path = self._convert_glb_to_obj_ply(glb_path, output_dir)

            # Step 5: Validate output
            self.report_progress(90, "Validating output")

            # Check GLB file size (should be >1KB for real geometry)
            glb_size = glb_path.stat().st_size
            if glb_size < 1024:
                return {
                    'status': 'failed',
                    'error': f"GLB file too small ({glb_size} bytes) - likely empty or placeholder"
                }

            self.report_progress(95, "Cleanup")

            return {
                'status': 'success',
                'mesh_path': str(obj_path) if obj_path else str(glb_path),
                'glb_path': str(glb_path),
                'ply_path': str(ply_path) if ply_path else None,
                'texture_path': None,  # Texture embedded in GLB
                'model': 'reconviagen',
                'backend': 'trellis-vggt'
            }

        except torch.cuda.OutOfMemoryError as e:
            logger.error(f"CUDA OOM during ReconViaGen inference: {e}")
            cleanup_gpu_memory()
            return {
                'status': 'failed',
                'error': "Out of GPU memory. TRELLIS requires ~16GB VRAM."
            }
        except Exception as e:
            logger.error(f"ReconViaGen inference failed: {e}", exc_info=True)
            return {
                'status': 'failed',
                'error': f"Reconstruction failed: {str(e)}"
            }
        finally:
            # Clean up to free VRAM for next model
            if self._pipeline is not None:
                self._pipeline.cleanup()
                self._pipeline = None

    def _load_images(self, views_dir: Path) -> List[Image.Image]:
        """Load and preprocess input images."""
        images = []
        view_files = sorted(views_dir.glob("view_*.png"))

        for view_file in view_files:
            try:
                img = Image.open(view_file).convert("RGB")
                images.append(img)
            except Exception as e:
                logger.warning(f"Failed to load {view_file}: {e}")

        return images

    def _convert_glb_to_obj_ply(self, glb_path: Path, output_dir: Path):
        """
        Convert GLB to OBJ and PLY formats for compatibility.

        Uses trimesh to load GLB and export to other formats.
        Returns (obj_path, ply_path) or (None, None) if conversion fails.
        """
        try:
            import trimesh

            # Load GLB
            mesh = trimesh.load(str(glb_path))

            # Handle scene vs mesh
            if isinstance(mesh, trimesh.Scene):
                # Merge all geometries
                mesh = mesh.dump(concatenate=True)

            if mesh is None or (hasattr(mesh, 'vertices') and len(mesh.vertices) == 0):
                logger.warning("GLB contained no geometry, skipping OBJ/PLY export")
                return None, None

            obj_path = output_dir / "mesh.obj"
            ply_path = output_dir / "mesh.ply"

            mesh.export(str(obj_path), file_type='obj')
            mesh.export(str(ply_path), file_type='ply')

            logger.info(f"Converted to OBJ ({obj_path}) and PLY ({ply_path})")
            return obj_path, ply_path

        except Exception as e:
            logger.warning(f"Failed to convert GLB to OBJ/PLY: {e}")
            return None, None

    @classmethod
    def download_weights(cls, force: bool = False) -> dict:
        """
        Download TRELLIS-VGGT model weights.

        Args:
            force: If True, re-download even if weights exist

        Returns:
            dict with status and weight paths
        """
        from huggingface_hub import snapshot_download

        weights_dir = WEIGHTS_PATH / "trellis-vggt"

        if weights_dir.exists() and not force:
            logger.info(f"Weights already exist at {weights_dir}")
            return {
                'status': 'exists',
                'path': str(weights_dir)
            }

        logger.info("Downloading TRELLIS-VGGT weights from Hugging Face...")

        try:
            path = snapshot_download(
                "Stable-X/trellis-vggt-v0-2",
                local_dir=str(weights_dir),
                local_dir_use_symlinks=False
            )

            logger.info(f"Weights downloaded to {path}")
            return {
                'status': 'downloaded',
                'path': path
            }

        except Exception as e:
            logger.error(f"Failed to download weights: {e}")
            return {
                'status': 'failed',
                'error': str(e)
            }
```

Key implementation notes:
- SPCONV_ALGO=native set at module top level (CRITICAL for spconv)
- Based on estheryang11/ReconViaGen app_refine.py pattern
- Uses `postprocessing_utils.to_glb(gs, mesh)` instead of manual mesh extraction
- Removed MASt3R references - VGGT is bundled in TRELLIS-VGGT pipeline
- Added GLB file size validation (>1KB for real geometry)
- Added GLB to OBJ/PLY conversion for compatibility
  </action>
  <verify>
Run: `python -c "from app.models.reconviagen import ReconViaGenModel; print('Import OK')"`
Run: `python -c "from app.models import get_model; m = get_model('reconviagen'); print(f'Model: {m.model_name}')"`
Check: No import errors, model factory still works
  </verify>
  <done>ReconViaGen STUB replaced with real TRELLIS implementation using to_glb pattern</done>
</task>

<task type="auto">
  <name>Task 2: Verify ReconViaGen implementation structure</name>
  <files></files>
  <action>
Verify the implementation is correct without loading the full model (which requires GPU + weights):

1. Check imports work:
```bash
docker run --rm 3d-recon-test:nvdiffrec python -c "
from app.models.reconviagen import ReconViaGenModel, REQUIRED_VRAM_GB, WEIGHTS_PATH
print(f'Required VRAM: {REQUIRED_VRAM_GB} GB')
print(f'Weights path: {WEIGHTS_PATH}')
print('Import successful')
"
```

2. Check model instantiation (without loading):
```bash
docker run --rm 3d-recon-test:nvdiffrec python -c "
from app.models.reconviagen import ReconViaGenModel
model = ReconViaGenModel()
print(f'Model name: {model.model_name}')
print(f'Device: {model._device}')
print(f'Pipeline loaded: {model._pipeline is not None}')
"
```

3. Check factory function works:
```bash
docker run --rm 3d-recon-test:nvdiffrec python -c "
from app.models import get_model, AVAILABLE_MODELS
print(f'Available models: {AVAILABLE_MODELS}')
model = get_model('reconviagen')
print(f'Got model: {model.model_name}')
"
```

4. Check existing tests pass:
```bash
docker run --rm 3d-recon-test:nvdiffrec pytest tests/ -v
```
  </action>
  <verify>
All verification commands succeed:
- ReconViaGenModel imports and instantiates
- Factory function returns correct model type
- No import errors or missing dependencies
- Existing tests pass
  </verify>
  <done>ReconViaGen implementation verified structurally correct</done>
</task>

</tasks>

<verification>
- ReconViaGenModel uses TrellisPipelineWrapper
- SPCONV_ALGO=native set at module level
- Mesh export uses postprocessing_utils.to_glb() (not manual extraction)
- Model can be instantiated without errors
- Factory function (get_model) works correctly
- Weight download method exists
- Existing tests pass
</verification>

<success_criteria>
- app/models/reconviagen.py uses real TRELLIS pipeline with to_glb export (not placeholder)
- SPCONV_ALGO environment variable set before trellis imports
- Model follows BaseReconstructionModel interface
- Weight download capability available
- No regression in existing tests
- GLB output validated >1KB (real geometry)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-cuda-12-upgrade-real-model-integration/03.1-04-SUMMARY.md`
</output>
