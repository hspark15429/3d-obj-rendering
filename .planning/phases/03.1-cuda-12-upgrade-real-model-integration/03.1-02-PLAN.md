---
phase: 03.1-cuda-12-upgrade
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - Dockerfile
  - app/models/trellis/__init__.py
  - app/models/trellis/pipeline.py
autonomous: true

must_haves:
  truths:
    - "TRELLIS pipeline can be imported without errors"
    - "spconv-cu120 loads and sparse convolutions work"
    - "flash-attn or xformers provides attention operations"
    - "TRELLIS model weights download successfully"
  artifacts:
    - path: "Dockerfile"
      provides: "TRELLIS dependencies installed"
      contains: "spconv-cu120"
    - path: "app/models/trellis/__init__.py"
      provides: "TRELLIS module initialization"
      min_lines: 5
    - path: "app/models/trellis/pipeline.py"
      provides: "Pipeline wrapper for TRELLIS-VGGT"
      min_lines: 50
  key_links:
    - from: "app/models/trellis/pipeline.py"
      to: "trellis.pipelines"
      via: "from_pretrained import"
      pattern: "TrellisVGGTTo3DPipeline"
---

<objective>
Install ReconViaGen/TRELLIS dependencies and create pipeline wrapper

Purpose: Enable TRELLIS-VGGT model loading which powers the ReconViaGen implementation
Output: Dockerfile with TRELLIS deps, pipeline wrapper module ready for use
</objective>

<execution_context>
@/home/devuser/.claude/get-shit-done/workflows/execute-plan.md
@/home/devuser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03.1-cuda-12-upgrade-real-model-integration/03.1-RESEARCH.md
@.planning/phases/03.1-cuda-12-upgrade-real-model-integration/03.1-01-SUMMARY.md
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TRELLIS dependencies to Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Add TRELLIS/ReconViaGen dependencies to Dockerfile after PyTorch installation:

1. Install spconv-cu120 (sparse convolutions):
```dockerfile
# Phase 3.1: TRELLIS/ReconViaGen dependencies
RUN pip install --no-cache-dir spconv-cu120==2.3.6
```

2. Install xformers (memory-efficient attention):
```dockerfile
RUN pip install --no-cache-dir xformers==0.0.27.post2
```

3. Install flash-attn from pre-built wheel (CRITICAL: do NOT build from source):
```dockerfile
# flash-attn pre-built wheel (building from source takes hours and often fails)
RUN pip install --no-cache-dir \
    https://github.com/Dao-AILab/flash-attention/releases/download/v2.7.0.post2/flash_attn-2.7.0.post2+cu12torch2.4cxx11abiFALSE-cp310-cp310-linux_x86_64.whl
```

4. Install transformers and einops for VGGT backbone:
```dockerfile
RUN pip install --no-cache-dir transformers==4.46.3 einops==0.8.1
```

5. Install huggingface_hub for model downloads:
```dockerfile
RUN pip install --no-cache-dir huggingface_hub==0.33.4
```

6. Clone estheryang11/ReconViaGen repo (includes TRELLIS as submodule):
```dockerfile
# Clone estheryang11/ReconViaGen (TRELLIS-VGGT implementation with app_refine.py)
# Uses --recursive to include TRELLIS submodule
RUN git clone --recursive --depth 1 https://github.com/estheryang11/ReconViaGen.git /app/reconviagen_src && \
    cp -r /app/reconviagen_src/trellis /app/ && \
    rm -rf /app/reconviagen_src
```

7. Set SPCONV_ALGO environment variable (CRITICAL for spconv to work with TRELLIS):
```dockerfile
ENV SPCONV_ALGO=native
```

Order matters: Install dependencies in order listed to avoid conflicts.
  </action>
  <verify>
Run: `docker build -t 3d-recon-test:trellis .`
Check: Build completes, all pip installs succeed
  </verify>
  <done>Dockerfile includes all TRELLIS dependencies (spconv, xformers, flash-attn, transformers) and estheryang11/ReconViaGen code</done>
</task>

<task type="auto">
  <name>Task 2: Create TRELLIS pipeline wrapper module</name>
  <files>app/models/trellis/__init__.py, app/models/trellis/pipeline.py</files>
  <action>
Create app/models/trellis/ directory with pipeline wrapper:

1. Create `app/models/trellis/__init__.py`:
```python
"""TRELLIS pipeline wrapper for ReconViaGen."""
from app.models.trellis.pipeline import TrellisPipelineWrapper

__all__ = ['TrellisPipelineWrapper']
```

2. Create `app/models/trellis/pipeline.py`:
```python
"""
TRELLIS-VGGT pipeline wrapper for 3D reconstruction.

Wraps the TRELLIS-VGGT pipeline with our interface conventions.
Based on: https://github.com/estheryang11/ReconViaGen (app_refine.py)
Reference: https://huggingface.co/spaces/Stable-X/ReconViaGen/blob/main/app.py
"""
import os
import logging
from pathlib import Path
from typing import List, Optional, Tuple

import torch
from PIL import Image

# CRITICAL: Set SPCONV_ALGO before importing trellis
# This must be done before any trellis imports or spconv will hang/crash
os.environ['SPCONV_ALGO'] = 'native'

logger = logging.getLogger(__name__)

# Model paths
DEFAULT_MODEL_ID = "Stable-X/trellis-vggt-v0-2"
WEIGHTS_DIR = Path("/app/weights/reconviagen")


class TrellisPipelineWrapper:
    """
    Wrapper around TrellisVGGTTo3DPipeline for ReconViaGen.

    Based on estheryang11/ReconViaGen app_refine.py which uses
    optimized camera registration from VGGT.

    Handles:
    - Lazy model loading
    - Image preprocessing
    - Inference with configurable parameters
    - Mesh extraction and export
    """

    def __init__(self, model_id: str = DEFAULT_MODEL_ID, device: str = "cuda"):
        self._model_id = model_id
        self._device = device
        self._pipeline = None
        self._loaded = False

    def load(self) -> None:
        """Load the TRELLIS pipeline."""
        if self._loaded:
            return

        logger.info(f"Loading TRELLIS pipeline from {self._model_id}")

        try:
            # Import here to defer heavy imports
            from trellis.pipelines import TrellisVGGTTo3DPipeline

            # Load from HuggingFace or local cache
            local_path = WEIGHTS_DIR / "trellis-vggt"
            if local_path.exists():
                logger.info(f"Loading from local cache: {local_path}")
                self._pipeline = TrellisVGGTTo3DPipeline.from_pretrained(str(local_path))
            else:
                logger.info(f"Loading from HuggingFace: {self._model_id}")
                self._pipeline = TrellisVGGTTo3DPipeline.from_pretrained(self._model_id)

            self._pipeline.to(self._device)
            self._loaded = True
            logger.info("TRELLIS pipeline loaded successfully")

        except Exception as e:
            logger.error(f"Failed to load TRELLIS pipeline: {e}")
            raise

    def is_loaded(self) -> bool:
        """Check if pipeline is loaded."""
        return self._loaded

    def run(
        self,
        images: List[Image.Image],
        seed: int = 42,
        sparse_steps: int = 30,
        sparse_cfg: float = 7.5,
        slat_steps: int = 12,
        slat_cfg: float = 3.0,
    ) -> Tuple[dict, any, any]:
        """
        Run reconstruction on input images.

        Args:
            images: List of PIL Images (multi-view input)
            seed: Random seed for reproducibility
            sparse_steps: Diffusion steps for sparse structure
            sparse_cfg: CFG strength for sparse structure
            slat_steps: Diffusion steps for SLAT
            slat_cfg: CFG strength for SLAT

        Returns:
            Tuple of (outputs dict, video1, video2)
            outputs contains 'gaussian' and 'mesh' keys
        """
        if not self._loaded:
            raise RuntimeError("Pipeline not loaded. Call load() first.")

        logger.info(f"Running TRELLIS inference on {len(images)} images")

        outputs, video1, video2 = self._pipeline.run(
            image=images,
            seed=seed,
            formats=["gaussian", "mesh"],
            preprocess_image=False,  # Images already preprocessed
            sparse_structure_sampler_params={
                "steps": sparse_steps,
                "cfg_strength": sparse_cfg
            },
            slat_sampler_params={
                "steps": slat_steps,
                "cfg_strength": slat_cfg
            },
            mode="multidiffusion",
        )

        logger.info("TRELLIS inference complete")
        return outputs, video1, video2

    def cleanup(self) -> None:
        """Release GPU memory."""
        if self._pipeline is not None:
            del self._pipeline
            self._pipeline = None
            self._loaded = False
            torch.cuda.empty_cache()
            logger.info("TRELLIS pipeline unloaded")
```

This wrapper:
- Sets SPCONV_ALGO=native before any trellis imports (CRITICAL)
- Defers heavy imports until load() is called
- Supports both HuggingFace and local weight loading
- Exposes configurable inference parameters
- Provides cleanup method for VRAM management
- References estheryang11/ReconViaGen app_refine.py pattern
  </action>
  <verify>
Run: `python -c "from app.models.trellis import TrellisPipelineWrapper; print('Import OK')"`
Check: No import errors (pipeline loading tested separately)
  </verify>
  <done>TRELLIS pipeline wrapper created with load/run/cleanup interface</done>
</task>

<task type="auto">
  <name>Task 3: Verify TRELLIS dependencies work together</name>
  <files></files>
  <action>
Build image and verify all TRELLIS dependencies:

1. Build updated image:
```bash
docker build -t 3d-recon-test:trellis .
```

2. Test spconv import:
```bash
docker run --gpus all --rm 3d-recon-test:trellis python -c "
import spconv.pytorch as spconv
print(f'spconv version: {spconv.__version__}')
# Quick sparse tensor test
import torch
features = torch.randn(100, 32).cuda()
indices = torch.randint(0, 64, (100, 4)).int().cuda()
indices[:, 0] = 0  # batch index
spatial_shape = [64, 64, 64]
batch_size = 1
sp = spconv.SparseConvTensor(features, indices, spatial_shape, batch_size)
print(f'Sparse tensor created: {sp.features.shape}')
"
```

3. Test flash-attn or xformers:
```bash
docker run --gpus all --rm 3d-recon-test:trellis python -c "
try:
    import flash_attn
    print(f'flash-attn available: {flash_attn.__version__}')
except ImportError:
    print('flash-attn not available, falling back to xformers')
    import xformers
    print(f'xformers available: {xformers.__version__}')
"
```

4. Test TRELLIS module import (without loading model):
```bash
docker run --gpus all --rm 3d-recon-test:trellis python -c "
import os
os.environ['SPCONV_ALGO'] = 'native'
from trellis.pipelines import TrellisVGGTTo3DPipeline
print('TRELLIS pipeline importable')
"
```

5. Test our wrapper import:
```bash
docker run --gpus all --rm 3d-recon-test:trellis python -c "
from app.models.trellis import TrellisPipelineWrapper
wrapper = TrellisPipelineWrapper()
print(f'Wrapper created, loaded={wrapper.is_loaded()}')
"
```
  </action>
  <verify>
All verification commands succeed:
- spconv creates sparse tensors on GPU
- flash-attn or xformers imports
- TRELLIS pipeline class is importable
- Our wrapper module works
  </verify>
  <done>TRELLIS dependencies verified working together in Docker container</done>
</task>

</tasks>

<verification>
- Docker build succeeds with all TRELLIS dependencies
- spconv-cu120 works with CUDA tensors
- flash-attn (preferred) or xformers (fallback) available
- TRELLIS pipeline class importable
- Our wrapper module initializes correctly
</verification>

<success_criteria>
- Dockerfile includes spconv-cu120, xformers, flash-attn, transformers, einops
- estheryang11/ReconViaGen cloned with --recursive flag (includes TRELLIS submodule)
- SPCONV_ALGO=native set in Dockerfile and pipeline.py
- app/models/trellis/pipeline.py provides TrellisPipelineWrapper class
- All imports work without errors in container
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-cuda-12-upgrade-real-model-integration/03.1-02-SUMMARY.md`
</output>
